// Synaptic background conductances according to the point conductance model (Destexhe et al., Neurosci., 2001).
// Excitatory and inhibitory conductance trains are generated by Ornstein-Uhlenbeck processes.

const int gaussianPoolSize = 100;                 
float gaussianNumbers[gaussianPoolSize] = {0.0};   


// When the program is uploaded to the microcontroller, this function is called in order to create
// a pool of Gaussian random numbers for subsequent use by the OU processes 
void GenerateGaussianNumbers() {
  float x1,x2,w;
  int nIter = round(gaussianPoolSize/2);
  for (int x=0; x<nIter; x++) {
    w = 20.0;
    // Marsaglia polar method (a.k.a. Box-Mueller-Marsaglia) to obtain Gaussian random numbers
    while (w >= 1.0) {
      x1 = 2.0 * random(1001)/1000.0 - 1.0;
      x2 = 2.0 * random(1001)/1000.0 - 1.0;
      w = x1*x1 + x2*x2;
    }
    w = sqrtf((-2.0*logf(w))/w);
    gaussianNumbers[2*x] = x1*w;
    gaussianNumbers[2*x+1] = x2*w;
  }
}

// This function calculates the current from the OU processes at every time step
// To integrate the OU processes, we use the approximation dt << tauExc,tauInh
float OrnsteinUhlenbeck_CH1(float v) {
  const float tauExc = 2.8;   // msec, time constant of excitatory process
  const float tauInh = 8.5;   // msec, time constant of inhibitory process   
  static float gOU1_CH1 = 0.0;         // nS, excitatory OU conductance
  static float gOU2_CH1 = 0.0;         // nS, inhibitory OU conductance
  float y1 = gaussianNumbers[random(gaussianPoolSize)];
  float y2 = gaussianNumbers[random(gaussianPoolSize)]; 
  // gOU1 is excitatory and gOU2 is inhibitory
  gOU1_CH1 = gOU1_CH1 + dt*(-(gOU1_CH1-OU1_mean_CH1)/tauExc) + sqrtf(OU1_D_CH1*dt)*y1;
  gOU2_CH1 = gOU2_CH1 + dt*(-(gOU2_CH1-OU2_mean_CH1)/tauInh) + sqrtf(OU2_D_CH1*dt)*y2;
  if (gOU1_CH1<0.0) gOU1_CH1=0.0;
  if (gOU2_CH1<0.0) gOU2_CH1=0.0;
  float current = -gOU1_CH1*v - gOU2_CH1*(v+80);    // Reversal potentials (0 mV excitatory, -80 mV inhibitory)
  return current;
}

float OrnsteinUhlenbeck_CH2(float v) {
  const float tauExc = 2.8;   // msec, time constant of excitatory process
  const float tauInh = 8.5;   // msec, time constant of inhibitory process   
  static float gOU1_CH2 = 0.0;         // nS, excitatory OU conductance
  static float gOU2_CH2 = 0.0;         // nS, inhibitory OU conductance
  float y1 = gaussianNumbers[random(gaussianPoolSize)];
  float y2 = gaussianNumbers[random(gaussianPoolSize)]; 
  // gOU1 is excitatory and gOU2 is inhibitory
  gOU1_CH2 = gOU1_CH2 + dt*(-(gOU1_CH2-OU1_mean_CH2)/tauExc) + sqrtf(OU1_D_CH2*dt)*y1;
  gOU2_CH2 = gOU2_CH2 + dt*(-(gOU2_CH2-OU2_mean_CH2)/tauInh) + sqrtf(OU2_D_CH2*dt)*y2;
  if (gOU1_CH2<0.0) gOU1_CH2=0.0;
  if (gOU2_CH2<0.0) gOU2_CH2=0.0;
  float current = -gOU1_CH2*v - gOU2_CH2*(v+80);    // Reversal potentials (0 mV excitatory, -80 mV inhibitory)
  return current;
}
